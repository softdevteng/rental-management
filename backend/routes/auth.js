const express = require('express');
const router = express.Router();
const { models } = require('../db');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const crypto = require('crypto');
const { sendPasswordReset } = require('../utils/mailer');

// Register (creates role-specific profile if missing)
router.post('/register', async (req, res) => {
  const { email, password, role, ref, name, idNumber, apartmentId, inviteCode } = req.body;
  try {
    if (!email || !password || !role) return res.status(400).json({ error: 'Email, password, role required' });
    // Only require name and idNumber for tenant and landlord; caretakers can register with invite code only
    if (role !== 'caretaker' && (!name || !idNumber)) return res.status(400).json({ error: 'name and idNumber are required' });
    let profileId = ref;
    if (role === 'tenant') {
      if (!profileId) {
        const existing = await models.Tenant.findOne({ where: { email } });
        if (existing) { await existing.update({ name, idNumber }); profileId = existing.id; }
        else { const t = await models.Tenant.create({ email, name, idNumber }); profileId = t.id; }
      }
    } else if (role === 'landlord') {
      if (!profileId) {
        const existing = await models.Landlord.findOne({ where: { email } });
        if (existing) { await existing.update({ name, idNumber }); profileId = existing.id; }
        else { const l = await models.Landlord.create({ email, name, idNumber }); profileId = l.id; }
      }
    } else if (role === 'caretaker') {
        // Caretaker must register with a valid invite code generated by landlord
        if (!inviteCode) return res.status(400).json({ error: 'inviteCode required for caretaker' });
        const inv = await models.CaretakerInvite.findOne({ where: { code: inviteCode } });
        if (!inv || (inv.expiresAt && inv.expiresAt < new Date()) || inv.usedAt) return res.status(400).json({ error: 'Invalid or expired invite code' });
        if (!profileId) {
          const c = await models.Caretaker.create({ email, name: name || null, idNumber: idNumber || null, estateId: inv.estateId || null, apartmentId: inv.apartmentId || null });
          profileId = c.id;
          await inv.update({ usedAt: new Date() });
        }
    } else {
      return res.status(400).json({ error: 'Invalid role' });
    }

    const hashed = await bcrypt.hash(password, 10);
  const user = await models.User.create({ email, password: hashed, role, refId: profileId });
  const token = jwt.sign({ id: user.id, role: user.role }, process.env.JWT_SECRET || 'secretkey', { expiresIn: '1d' });
    res.status(201).json({ message: 'User registered', token, role: user.role });
  } catch (err) {
    res.status(400).json({ error: err.message });
  }
});

// Login
router.post('/login', async (req, res) => {
  const { email, password } = req.body;
  try {
    const user = await models.User.findOne({ where: { email } });
    if (!user) return res.status(400).json({ error: 'Invalid credentials' });
    const isMatch = await bcrypt.compare(password, user.password);
    if (!isMatch) return res.status(400).json({ error: 'Invalid credentials' });
  const token = jwt.sign({ id: user.id, role: user.role }, process.env.JWT_SECRET || 'secretkey', { expiresIn: '1d' });
    res.json({ token, role: user.role });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});
// Forgot password
router.post('/forgot', async (req, res) => {
  const { email } = req.body;
  try {
    const user = await models.User.findOne({ where: { email } });
    if (!user) return res.status(200).json({ message: 'If the email exists, a reset link was sent' });
    const token = crypto.randomBytes(20).toString('hex');
    await user.update({ passwordResetToken: token, passwordResetExpires: new Date(Date.now() + 1000*60*15) });
  const resetUrl = `${process.env.FRONTEND_URL || 'http://localhost:3000'}/reset-password?token=${token}&email=${encodeURIComponent(email)}`;
  try {
    const result = await sendPasswordReset({ to: email, resetUrl });
    if (result && result.fallback) {
      // No SMTP configured: include link in response for development convenience
      return res.json({ message: 'Reset link generated (dev mode)', resetUrl });
    }
  } catch (e) {
    console.log('Password reset link:', resetUrl);
    return res.json({ message: 'Reset link generated', resetUrl });
  }
    res.json({ message: 'If the email exists, a reset link was sent' });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// Reset password
router.post('/reset', async (req, res) => {
  const { email, token, password } = req.body;
  try {
    const user = await models.User.findOne({ where: { email, passwordResetToken: token } });
    if (!user || !user.passwordResetExpires || user.passwordResetExpires < new Date()) return res.status(400).json({ error: 'Invalid or expired token' });
    const hashed = await bcrypt.hash(password, 10);
    await user.update({ password: hashed, passwordResetToken: null, passwordResetExpires: null });
    res.json({ message: 'Password updated. You can sign in now.' });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

module.exports = router;
